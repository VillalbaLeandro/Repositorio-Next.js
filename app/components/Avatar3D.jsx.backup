'use client';

import React, { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import { Canvas, useFrame } from '@react-three/fiber';
import { useGLTF, OrbitControls, Sparkles, Float } from '@react-three/drei';

function useAdvancedHologram() {
    const uniforms = useMemo(() => ({
        uTime: { value: 0 },
        uFresnelIntensity: { value: 2.5 },
        uFresnelPower: { value: 3.0 }, // Aumentado para un borde más fino
        uSliceCount: { value: 50.0 },
        uSliceThickness: { value: 0.015 },
    }), []);

    const material = useMemo(() => {
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color('#00151a'),
            emissive: new THREE.Color('#00ffff'),
            emissiveIntensity: 1.5,
            transparent: true,
            opacity: 0.35,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
        });

        mat.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = uniforms.uTime;
            shader.uniforms.uFresnelIntensity = uniforms.uFresnelIntensity;
            shader.uniforms.uFresnelPower = uniforms.uFresnelPower;
            shader.uniforms.uSliceCount = uniforms.uSliceCount;
            shader.uniforms.uSliceThickness = uniforms.uSliceThickness;

            shader.vertexShader = `
                varying vec3 vWorldPosition;
                varying vec3 vNormalView;
                varying float vObjectY;
                ${shader.vertexShader}
            `.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                vObjectY = position.y;
                // Efecto de ruido en la posición para el "flicker"
                transformed.x += sin(position.y * 10.0 + uTime * 4.0) * 0.005;
                `
            ).replace(
                '#include <worldpos_vertex>',
                `
                #include <worldpos_vertex>
                vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                vNormalView = normalize(normalMatrix * normal);
                `
            );

            shader.fragmentShader = `
                uniform float uTime;
                uniform float uFresnelIntensity;
                uniform float uFresnelPower;
                uniform float uSliceCount;
                uniform float uSliceThickness;
                varying vec3 vWorldPosition;
                varying vec3 vNormalView;
                varying float vObjectY;
                ${shader.fragmentShader}
            `.replace(
                '#include <output_fragment>',
                `
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - abs(dot(vNormalView, viewDir)), uFresnelPower);
                
                // Slices usando posición de mundo para que sean estables
                float slice = smoothstep(0.0, uSliceThickness, fract(vWorldPosition.y * uSliceCount - uTime * 0.4));
                slice *= smoothstep(uSliceThickness * 2.0, uSliceThickness, fract(vWorldPosition.y * uSliceCount - uTime * 0.4));

                // Scanlines rápidas
                float scanline = sin(vWorldPosition.y * 200.0 - uTime * 15.0) * 0.08;
                
                // Pequeño pulso de brillo
                float flicker = (sin(uTime * 20.0) * 0.02) + 1.0;

                vec3 holoColor = emissive + (vec3(0.5, 1.0, 1.0) * fresnel * uFresnelIntensity);
                float alpha = (0.2 + slice * 0.6 + scanline) * fresnel;

                gl_FragColor = vec4(holoColor * flicker, alpha);
                `
            );
        };
        return mat;
    }, [uniforms]);

    return { material, uniforms };
}

function Model(props) {
    const { scene } = useGLTF('/img/myPics/hologram.glb');
    const { material, uniforms } = useAdvancedHologram();

    useFrame((state) => {
        uniforms.uTime.value = state.clock.getElapsedTime();
    });

    useEffect(() => {
        scene.traverse((child) => {
            if (child.isMesh && !child.userData.isWireframe) {
                child.material = material;
                if (!child.getObjectByName('wireframe-overlay')) {
                    const wireMat = new THREE.MeshBasicMaterial({
                        color: '#00ffff',
                        wireframe: true,
                        transparent: true,
                        opacity: 0.04,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending,
                    });
                    const wire = new THREE.Mesh(child.geometry, wireMat);
                    wire.name = 'wireframe-overlay';
                    wire.userData.isWireframe = true;
                    child.add(wire);
                }
            }
        });
    }, [scene, material]);

    return (
        <Float speed={2} rotationIntensity={0.1} floatIntensity={0.3}>
            <primitive object={scene} {...props} />
        </Float>
    );
}

export default function Avatar3D() {
    return (
        <div className="w-full h-[550px] bg-transparent overflow-hidden">
            <Canvas
                // CAMBIO CLAVE: FOV bajo (20) y cámara alejada (8) para evitar deformación
                camera={{ position: [0, 0, 8], fov: 20 }}
                gl={{
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                }}
                onCreated={({ gl }) => {
                    gl.setClearColor(0x000000, 0);
                }}
            >
                <ambientLight intensity={1} />
                <Sparkles count={60} scale={[4, 6, 4]} size={1.5} speed={0.2} color="#00ffff" />

                <group position={[0, -1.6, 0]}>
                    <Model scale={5.5} />
                </group>

                <OrbitControls
                    enableZoom={false}
                    enablePan={false}
                    autoRotate
                    autoRotateSpeed={0.5}
                    // Limitamos la rotación vertical para que no se vea desde ángulos extraños
                    maxPolarAngle={Math.PI / 1.7}
                    minPolarAngle={Math.PI / 2.3}
                />
            </Canvas>
        </div>
    );
}

useGLTF.preload('/img/myPics/hologram.glb');